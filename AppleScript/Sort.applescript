use AppleScript version "2.4"use framework "Foundation"use scripting additionson run		script pageNum		property digit : my isDigit		on |λ|(para)			set s to strip(para)			if 0 < length of s and all(digit, (characters of s)) then				{s as integer}			else				{}			end if		end |λ|	end script		intercalateS(", ", ¬		sort(concatMap(pageNum, ¬			paragraphs of (the clipboard))))end run-- GENERIC FUNCTIONS -------------------------------------------------------- https://github.com/RobTrew/prelude-applescript-- Applied to a predicate and a list, `all` determines if all elements -- of the list satisfy the predicate.-- all :: (a -> Bool) -> [a] -> Boolon all(f, xs)	tell mReturn(f)		set lng to length of xs		repeat with i from 1 to lng			if not |λ|(item i of xs, i, xs) then return false		end repeat		true	end tellend all-- concatMap :: (a -> [b]) -> [a] -> [b]on concatMap(f, xs)	set lng to length of xs	if 0 < lng and class of xs is string then		set acc to ""	else		set acc to {}	end if	tell mReturn(f)		repeat with i from 1 to lng			set acc to acc & |λ|(item i of xs, i, xs)		end repeat	end tell	return accend concatMap-- drop :: Int -> [a] -> [a]on drop(n, xs)	if n < length of xs then		if text is class of xs then			text (n + 1) thru -1 of xs		else			items (n + 1) thru -1 of xs		end if	else		{}	end ifend drop-- dropWhile :: (a -> Bool) -> [a] -> [a]-- dropWhile :: (Char -> Bool) -> String -> Stringon dropWhile(p, xs)	set lng to length of xs	set i to 1	tell mReturn(p)		repeat while i ≤ lng and |λ|(item i of xs)			set i to i + 1		end repeat	end tell	drop(i - 1, xs)end dropWhile-- dropWhileEnd :: (a -> Bool) -> [a] -> [a]-- dropWhileEnd :: (Char -> Bool) -> String -> Stringon dropWhileEnd(p, xs)	set i to length of xs	tell mReturn(p)		repeat while i > 0 and |λ|(item i of xs)			set i to i - 1		end repeat	end tell	take(i, xs)end dropWhileEnd-- intercalateS :: String -> [String] -> Stringon intercalateS(sep, xs)	set {dlm, my text item delimiters} to {my text item delimiters, sep}	set s to xs as text	set my text item delimiters to dlm	return send intercalateS-- isDigit :: Char -> Boolon isDigit(c)	set n to (id of c)	48 ≤ n and 57 ≥ nend isDigit-- isSpace :: Char -> Boolon isSpace(c)	set i to id of c	i = 32 or (i ≥ 9 and i ≤ 13)end isSpace-- min :: Ord a => a -> a -> aon min(x, y)	if y < x then		y	else		x	end ifend min-- Lift 2nd class handler function into 1st class script wrapper -- mReturn :: First-class m => (a -> b) -> m (a -> b)on mReturn(f)	if class of f is script then		f	else		script			property |λ| : f		end script	end ifend mReturn-- sort :: Ord a => [a] -> [a]on sort(xs)	((current application's NSArray's arrayWithArray:xs)'s ¬		sortedArrayUsingSelector:"compare:") as listend sort-- strip :: String -> Stringon strip(s)	script isSpace		on |λ|(c)			set i to id of c			i = 32 or (i ≥ 9 and i ≤ 13)		end |λ|	end script	dropWhile(isSpace, dropWhileEnd(isSpace, s))end strip-- take :: Int -> [a] -> [a]on take(n, xs)	if class of xs is string then		if n > 0 then			text 1 thru min(n, length of xs) of xs		else			""		end if	else		if n > 0 then			items 1 thru min(n, length of xs) of xs		else			{}		end if	end ifend take